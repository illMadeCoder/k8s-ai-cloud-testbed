version: '3'

silent: true

vars:
  ARGOCD_NAMESPACE: argocd
  ARGOCD_VALUES: argocd-apps/components/core/argocd/values.yaml

tasks:
  default:
    desc: List available tasks
    cmds:
      - task --list

  # =============================================================================
  # Bootstrap
  # =============================================================================
  bootstrap:
    desc: Bootstrap minikube with ArgoCD
    cmds:
      - helm repo add argo https://argoproj.github.io/argo-helm 2>/dev/null || true
      - helm repo update argo
      - |
        helm install argocd argo/argo-cd \
          --namespace {{.ARGOCD_NAMESPACE}} \
          --create-namespace \
          --values {{.ARGOCD_VALUES}} \
          --wait
      - task: argocd:password

  bootstrap:upgrade:
    desc: Upgrade ArgoCD installation
    cmds:
      - helm repo update argo
      - |
        helm upgrade argocd argo/argo-cd \
          --namespace {{.ARGOCD_NAMESPACE}} \
          --values {{.ARGOCD_VALUES}} \
          --wait

  # =============================================================================
  # Status
  # =============================================================================
  status:
    desc: Show status of all ArgoCD applications
    cmds:
      - kubectl get applications -n {{.ARGOCD_NAMESPACE}}

  # =============================================================================
  # ArgoCD
  # =============================================================================
  argocd:password:
    desc: Display ArgoCD admin password
    cmds:
      - |
        echo "ArgoCD Credentials:"
        echo "  Username: admin"
        echo "  Password: $(kubectl -n {{.ARGOCD_NAMESPACE}} get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d)"

  argocd:ui:
    desc: Port-forward ArgoCD UI to localhost:8080
    cmds:
      - echo "ArgoCD UI available at https://localhost:8080"
      - kubectl port-forward svc/argocd-server -n {{.ARGOCD_NAMESPACE}} 8080:443

  # =============================================================================
  # ArgoCD Apps (for tinkering)
  # =============================================================================
  argocd-deploy:minikube:
    desc: "Deploy ArgoCD apps: task argocd-deploy:minikube -- <paths...>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task argocd-deploy:minikube -- <path> [path...]"
          echo ""
          echo "Examples:"
          echo "  task argocd-deploy:minikube -- argocd-apps/core-app-of-apps.yaml argocd-apps/stacks/loki.yaml"
          exit 1
        fi

        for path in {{.CLI_ARGS}}; do
          if [ ! -f "$path" ]; then
            echo "ERROR: File not found: $path"
            exit 1
          fi
          echo "=== Deploying: $path ==="
          kubectl apply -f "$path"
        done

        echo ""
        echo "Waiting for ArgoCD to sync..."
        sleep 5
        kubectl get applications -n argocd

  # =============================================================================
  # Experiments
  # =============================================================================
  exp:list:
    desc: List all available experiments
    cmds:
      - |
        echo "Available Experiments:"
        echo "======================"
        for dir in experiments/*/; do
          name=$(basename "$dir")
          printf "  - %s\n" "$name"
        done

  exp:deploy:minikube:
    desc: "Deploy experiment: task exp:deploy:minikube -- <experiment-path>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:deploy:minikube -- <experiment-path>"
          echo ""
          echo "Example: task exp:deploy:minikube -- experiments/http-baseline"
          exit 1
        fi

        EXP_PATH="{{.CLI_ARGS}}"
        ARGOCD_DIR="$EXP_PATH/argocd"
        if [ ! -d "$ARGOCD_DIR" ]; then
          echo "ERROR: argocd directory not found at $ARGOCD_DIR"
          exit 1
        fi
        echo "Deploying experiment: $EXP_PATH"
        for f in "$ARGOCD_DIR"/*.yaml; do
          echo "  Applying: $(basename $f)"
          kubectl apply -f "$f"
        done
        echo ""
        echo "Waiting for ArgoCD to sync..."
        sleep 5
        kubectl get applications -n argocd

  exp:destroy:minikube:
    desc: "Destroy experiment: task exp:destroy:minikube -- <experiment-path>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:destroy:minikube -- <experiment-path>"
          echo ""
          echo "Example: task exp:destroy:minikube -- experiments/http-baseline"
          exit 1
        fi

        EXP_PATH="{{.CLI_ARGS}}"
        EXP_NAME=$(basename "$EXP_PATH")
        echo "Destroying experiment: $EXP_NAME"
        kubectl delete application -n argocd -l experiment=$EXP_NAME --ignore-not-found

  exp:conduct:minikube:
    desc: "Conduct experiment (idempotent): task exp:conduct:minikube -- <experiment-path>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:conduct:minikube -- <experiment-path> [USERS=10] [DURATION=60s]"
          exit 1
        fi

        EXP_PATH="{{.CLI_ARGS}}"
        EXP_NAME=$(basename "$EXP_PATH")
        WORKFLOW_FILE="$EXP_PATH/workflow/experiment.yaml"

        if [ ! -f "$WORKFLOW_FILE" ]; then
          echo "ERROR: Workflow not found at $WORKFLOW_FILE"
          exit 1
        fi

        USERS={{.USERS | default "10"}}
        DURATION={{.DURATION | default "60s"}}
        TARGET={{.TARGET | default "http://demo-app.demo.svc:80"}}

        echo "=============================================="
        echo "  CONDUCTING EXPERIMENT: $EXP_NAME"
        echo "=============================================="
        echo "  Users: $USERS"
        echo "  Duration: $DURATION"
        echo "  Target: $TARGET"
        echo ""

        # Step 1: Clean up any previous run (idempotent)
        echo "=== Step 1/5: Cleaning up previous run ==="
        kubectl delete application -n argocd -l experiment=$EXP_NAME --ignore-not-found
        sleep 3

        # Step 2: Deploy
        echo ""
        echo "=== Step 2/5: Deploying experiment ==="
        task exp:deploy:minikube -- "$EXP_PATH"

        # Step 3: Submit workflow
        echo ""
        echo "=== Step 3/5: Submitting workflow ==="
        WORKFLOW_NAME=$(argo submit "$WORKFLOW_FILE" \
          -p users="$USERS" \
          -p duration="$DURATION" \
          -p target-url="$TARGET" \
          -o name -n argo-workflows 2>/dev/null || \
          kubectl create -f "$WORKFLOW_FILE" -o name)
        echo "Workflow: $WORKFLOW_NAME"

        # Step 4: Wait for completion
        echo ""
        echo "=== Step 4/5: Waiting for workflow completion ==="
        argo wait "$WORKFLOW_NAME" -n argo-workflows 2>/dev/null || \
          kubectl wait "$WORKFLOW_NAME" --for=condition=Completed --timeout=30m -n argo-workflows

        # Get results
        echo ""
        echo "=== Workflow Results ==="
        argo get "$WORKFLOW_NAME" -n argo-workflows 2>/dev/null || \
          kubectl get "$WORKFLOW_NAME" -n argo-workflows -o yaml

        # Step 5: Cleanup
        echo ""
        echo "=== Step 5/5: Cleaning up ==="
        kubectl delete application -n argocd -l experiment=$EXP_NAME --ignore-not-found

        echo ""
        echo "=============================================="
        echo "  EXPERIMENT COMPLETE"
        echo "=============================================="

  # =============================================================================
  # Production (Azure AKS)
  # =============================================================================
  exp:deploy:prod:
    desc: "Deploy experiment to prod: task exp:deploy:prod -- <experiment-path>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:deploy:prod -- <experiment-path>"
          exit 1
        fi
        EXP_PATH="{{.CLI_ARGS}}"
        TF_DIR="$EXP_PATH/terraform/prod"
        ARGOCD_DIR="$EXP_PATH/argocd"

        if [ ! -d "$TF_DIR" ]; then
          echo "ERROR: terraform/prod directory not found at $TF_DIR"
          exit 1
        fi

        echo "=== Deploying infrastructure ==="
        cd "$TF_DIR" && terraform init && terraform apply -auto-approve

        echo ""
        echo "=== Deploying ArgoCD apps ==="
        CLUSTERS=$(cd "$TF_DIR" && terraform output -json cluster_names | jq -r '.[]')
        for CLUSTER in $CLUSTERS; do
          ARGOCD_FILE="$ARGOCD_DIR/${CLUSTER}.yaml"
          KUBECONFIG_FILE="$TF_DIR/kubeconfig-${CLUSTER}"
          if [ -f "$ARGOCD_FILE" ]; then
            echo "Deploying to: $CLUSTER"
            KUBECONFIG="$KUBECONFIG_FILE" kubectl apply -f "$ARGOCD_FILE"
          fi
        done

  exp:destroy:prod:
    desc: "Destroy prod infrastructure: task exp:destroy:prod -- <experiment-path>"
    prompt: This will DESTROY production infrastructure. Continue?
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:destroy:prod -- <experiment-path>"
          exit 1
        fi
        EXP_PATH="{{.CLI_ARGS}}"
        TF_DIR="$EXP_PATH/terraform/prod"
        if [ ! -d "$TF_DIR" ]; then
          echo "ERROR: terraform/prod not found at $TF_DIR"
          exit 1
        fi
        echo "Destroying infrastructure..."
        cd "$TF_DIR" && terraform destroy -auto-approve

  exp:conduct:prod:
    desc: "Conduct experiment on prod: task exp:conduct:prod -- <experiment-path>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task exp:conduct:prod -- <experiment-path> [USERS=10] [DURATION=60s]"
          exit 1
        fi

        EXP_PATH="{{.CLI_ARGS}}"
        TF_DIR="$EXP_PATH/terraform/prod"
        WORKFLOW_FILE="$EXP_PATH/workflow/experiment.yaml"

        if [ ! -d "$TF_DIR" ]; then
          echo "ERROR: terraform/prod not found at $TF_DIR"
          exit 1
        fi

        USERS={{.USERS | default "10"}}
        DURATION={{.DURATION | default "60s"}}

        echo "=============================================="
        echo "  CONDUCTING PROD EXPERIMENT: $EXP_PATH"
        echo "=============================================="

        # Deploy
        task exp:deploy:prod -- "$EXP_PATH"

        # Get target URL
        KUBECONFIG="$TF_DIR/kubeconfig-target" kubectl wait --for=condition=available deploy/demo-app -n demo --timeout=5m
        TARGET_IP=$(KUBECONFIG="$TF_DIR/kubeconfig-target" kubectl get svc demo-app -n demo -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        TARGET_URL="http://${TARGET_IP}"
        echo "Target: $TARGET_URL"

        # Run workflow
        WORKFLOW_NAME=$(KUBECONFIG="$TF_DIR/kubeconfig-loadgen" argo submit "$WORKFLOW_FILE" \
          -p users="$USERS" -p duration="$DURATION" -p target-url="$TARGET_URL" \
          -o name -n argo-workflows)
        KUBECONFIG="$TF_DIR/kubeconfig-loadgen" argo wait "$WORKFLOW_NAME" -n argo-workflows
        KUBECONFIG="$TF_DIR/kubeconfig-loadgen" argo get "$WORKFLOW_NAME" -n argo-workflows

        # Destroy
        cd "$TF_DIR" && terraform destroy -auto-approve

        echo "=============================================="
        echo "  EXPERIMENT COMPLETE"
        echo "=============================================="
