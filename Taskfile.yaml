version: '3'

silent: true

vars:
  ARGOCD_NAMESPACE: argocd
  ARGOCD_VALUES: manifests/argocd/values.yaml
  ARGO_WF_NAMESPACE: argo-workflows
  EXPERIMENTS_DIR: experiments
  TERRAFORM_DIR: terraform

tasks:
  default:
    desc: List available tasks
    cmds:
      - task --list

  # =============================================================================
  # Bootstrap
  # =============================================================================
  bootstrap:
    desc: Bootstrap the cluster with ArgoCD (installs ArgoCD + app-of-apps)
    cmds:
      - helm repo add argo https://argoproj.github.io/argo-helm 2>/dev/null || true
      - helm repo update argo
      - |
        helm install argocd argo/argo-cd \
          --namespace {{.ARGOCD_NAMESPACE}} \
          --create-namespace \
          --values {{.ARGOCD_VALUES}} \
          --wait
      - task: argocd:password

  bootstrap:upgrade:
    desc: Upgrade ArgoCD installation
    cmds:
      - helm repo update argo
      - |
        helm upgrade argocd argo/argo-cd \
          --namespace {{.ARGOCD_NAMESPACE}} \
          --values {{.ARGOCD_VALUES}} \
          --wait

  # =============================================================================
  # Status
  # =============================================================================
  status:
    desc: Show status of all ArgoCD applications
    cmds:
      - kubectl get applications -n {{.ARGOCD_NAMESPACE}}

  status:wide:
    desc: Show detailed status of all ArgoCD applications
    cmds:
      - kubectl get applications -n {{.ARGOCD_NAMESPACE}} -o wide

  status:health:
    desc: Show only unhealthy applications
    cmds:
      - |
        kubectl get applications -n {{.ARGOCD_NAMESPACE}} -o json | \
          jq -r '.items[] | select(.status.health.status != "Healthy") | "\(.metadata.name): \(.status.health.status) - \(.status.sync.status)"'

  # =============================================================================
  # ArgoCD
  # =============================================================================
  argocd:password:
    desc: Display ArgoCD admin password
    cmds:
      - |
        echo "ArgoCD Credentials:"
        echo "  Username: admin"
        echo "  Password: $(kubectl -n {{.ARGOCD_NAMESPACE}} get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d)"

  argocd:ui:
    desc: Port-forward ArgoCD UI to localhost:8080
    cmds:
      - echo "ArgoCD UI available at https://localhost:8080"
      - kubectl port-forward svc/argocd-server -n {{.ARGOCD_NAMESPACE}} 8080:443

  argocd:sync:
    desc: Sync all applications
    cmds:
      - kubectl -n {{.ARGOCD_NAMESPACE}} patch application app-of-apps --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

  # =============================================================================
  # Port Forwards (run in background with &)
  # =============================================================================
  pf:grafana:
    desc: Port-forward Grafana to localhost:3000
    cmds:
      - echo "Grafana available at http://localhost:3000 (admin/prom-operator)"
      - kubectl port-forward svc/kube-prometheus-stack-grafana -n observability 3000:80

  pf:prometheus:
    desc: Port-forward Prometheus to localhost:9090
    cmds:
      - echo "Prometheus available at http://localhost:9090"
      - kubectl port-forward svc/kube-prometheus-stack-prometheus -n observability 9090:9090

  pf:vault:
    desc: Port-forward Vault to localhost:8200
    cmds:
      - echo "Vault available at http://localhost:8200"
      - kubectl port-forward svc/vault -n vault 8200:8200

  pf:argo-workflows:
    desc: Port-forward Argo Workflows UI to localhost:2746
    cmds:
      - echo "Argo Workflows available at http://localhost:2746"
      - kubectl port-forward svc/argo-workflows-server -n argo-workflows 2746:2746

  # =============================================================================
  # Cleanup
  # =============================================================================
  clean:argocd:
    desc: Uninstall ArgoCD (WARNING - removes all managed applications)
    prompt: This will remove ArgoCD and all managed applications. Continue?
    cmds:
      - helm uninstall argocd -n {{.ARGOCD_NAMESPACE}} || true
      - kubectl delete namespace {{.ARGOCD_NAMESPACE}} --ignore-not-found

  clean:all:
    desc: Remove all lab namespaces (WARNING - destructive)
    prompt: This will delete all lab namespaces. Continue?
    cmds:
      - kubectl delete namespace argocd --ignore-not-found
      - kubectl delete namespace observability --ignore-not-found
      - kubectl delete namespace vault --ignore-not-found
      - kubectl delete namespace cert-manager --ignore-not-found
      - kubectl delete namespace argo-workflows --ignore-not-found
      - kubectl delete namespace locust --ignore-not-found

  # =============================================================================
  # Experiments
  # =============================================================================
  exp:list:
    desc: List all available experiments
    cmds:
      - |
        echo "Available Experiments:"
        echo "======================"
        for dir in {{.EXPERIMENTS_DIR}}/*/; do
          if [ -f "${dir}experiment.yaml" ]; then
            name=$(basename "$dir")
            printf "  - %s\n" "$name"
          fi
        done

  exp:validate:
    desc: Validate an experiment (NAME=<experiment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task exp:validate NAME=<experiment-name>"
          exit 1
        fi
        CONFIG="{{.EXPERIMENTS_DIR}}/{{.NAME}}/experiment.yaml"
        if [ ! -f "$CONFIG" ]; then
          echo "ERROR: experiment.yaml not found at $CONFIG"
          exit 1
        fi
        echo "Validating {{.NAME}}..."
        python3 -c "import yaml; yaml.safe_load(open('$CONFIG'))" && echo "OK: Valid YAML"

  exp:deploy:
    desc: Deploy experiment's app-of-apps (NAME=<experiment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task exp:deploy NAME=<experiment-name>"
          exit 1
        fi
        APP_OF_APPS="{{.EXPERIMENTS_DIR}}/{{.NAME}}/argocd/app-of-apps.yaml"
        if [ ! -f "$APP_OF_APPS" ]; then
          echo "ERROR: app-of-apps.yaml not found at $APP_OF_APPS"
          exit 1
        fi
        echo "Deploying app-of-apps for experiment: {{.NAME}}"
        kubectl apply -f "$APP_OF_APPS"
        echo "Waiting for ArgoCD to sync applications..."
        sleep 5
        kubectl get applications -n argocd -l experiment={{.NAME}}

  exp:undeploy:
    desc: Remove experiment's app-of-apps (NAME=<experiment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task exp:undeploy NAME=<experiment-name>"
          exit 1
        fi
        echo "Removing app-of-apps for experiment: {{.NAME}}"
        kubectl delete application -n argocd -l experiment={{.NAME}} --ignore-not-found

  exp:run:
    desc: Run an experiment workflow (NAME=<experiment> ENV=<environment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task exp:run NAME=<experiment-name> [ENV=minikube]"
          exit 1
        fi
        ENV={{.ENV | default "minikube"}}
        echo "Starting experiment: {{.NAME}} on $ENV"
        argo submit -n {{.ARGO_WF_NAMESPACE}} \
          --from workflowtemplate/experiment-lifecycle \
          -p experiment-name="{{.NAME}}" \
          -p environment="$ENV" \
          --labels app=experiment-framework,experiment={{.NAME}}
        echo ""
        echo "Watch with: task exp:watch"

  exp:status:
    desc: Show status of experiment workflows
    cmds:
      - kubectl get workflows -n {{.ARGO_WF_NAMESPACE}} -l app=experiment-framework

  exp:watch:
    desc: Watch the latest experiment workflow
    cmds:
      - argo watch -n {{.ARGO_WF_NAMESPACE}} @latest

  exp:logs:
    desc: Get logs from experiment (NAME=<experiment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          argo logs -n {{.ARGO_WF_NAMESPACE}} @latest
        else
          WORKFLOW=$(kubectl get workflows -n {{.ARGO_WF_NAMESPACE}} \
            -l experiment={{.NAME}} \
            --sort-by=.metadata.creationTimestamp \
            -o jsonpath='{.items[-1].metadata.name}')
          argo logs -n {{.ARGO_WF_NAMESPACE}} "$WORKFLOW"
        fi

  exp:stop:
    desc: Stop a running experiment (NAME=<experiment>)
    cmds:
      - |
        if [ -z "{{.NAME}}" ]; then
          echo "Usage: task exp:stop NAME=<experiment-name>"
          exit 1
        fi
        WORKFLOW=$(kubectl get workflows -n {{.ARGO_WF_NAMESPACE}} \
          -l experiment={{.NAME}} \
          --field-selector=status.phase=Running \
          -o jsonpath='{.items[0].metadata.name}')
        if [ -n "$WORKFLOW" ]; then
          argo stop -n {{.ARGO_WF_NAMESPACE}} "$WORKFLOW"
        else
          echo "No running workflow found for {{.NAME}}"
        fi

  exp:clean:
    desc: Clean up experiment workflows
    prompt: Delete all experiment workflows?
    cmds:
      - kubectl delete workflows -n {{.ARGO_WF_NAMESPACE}} -l app=experiment-framework

  exp:templates:install:
    desc: Install experiment WorkflowTemplates
    cmds:
      - kubectl apply -f {{.EXPERIMENTS_DIR}}/_templates/

  # =============================================================================
  # Terraform
  # =============================================================================
  tf:init:
    desc: Initialize Terraform for an environment (ENV=<environment>)
    cmds:
      - |
        ENV={{.ENV | default "minikube"}}
        cd {{.TERRAFORM_DIR}}/environments/$ENV && terraform init

  tf:plan:
    desc: Plan Terraform changes (ENV=<environment>)
    cmds:
      - |
        ENV={{.ENV | default "minikube"}}
        cd {{.TERRAFORM_DIR}}/environments/$ENV && terraform plan

  tf:apply:
    desc: Apply Terraform changes (ENV=<environment>)
    prompt: Apply Terraform changes?
    cmds:
      - |
        ENV={{.ENV | default "minikube"}}
        cd {{.TERRAFORM_DIR}}/environments/$ENV && terraform apply

  tf:destroy:
    desc: Destroy Terraform infrastructure (ENV=<environment>)
    prompt: This will DESTROY infrastructure. Continue?
    cmds:
      - |
        ENV={{.ENV | default "minikube"}}
        cd {{.TERRAFORM_DIR}}/environments/$ENV && terraform destroy
