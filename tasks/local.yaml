version: '3'

silent: true

vars:
  ORCHESTRATOR_CLUSTER: orchestrator
  ARGOCD_NAMESPACE: argocd
  ARGOCD_VALUES: experiments/components/components/core/argocd/values.yaml
  # Container names for local infrastructure
  CPK_CONTAINER: cloud-provider-kind
  DNSMASQ_CONTAINER: kind-dnsmasq
  DNSMASQ_DOMAIN: k8s.local

tasks:
  # =============================================================================
  # Internal Helpers - Docker-based infrastructure
  # =============================================================================
  _ensure-cloud-provider-kind:
    internal: true
    cmds:
      - |
        # Check if already running
        if docker ps --format '{{.Names}}' | grep -q "^{{.CPK_CONTAINER}}$"; then
          echo "  [cloud-provider-kind] Already running"
          exit 0
        fi

        # Remove any stopped container with same name
        docker rm -f {{.CPK_CONTAINER}} 2>/dev/null || true

        echo "  [cloud-provider-kind] Starting container..."
        docker run -d \
          --name {{.CPK_CONTAINER}} \
          --network kind \
          --restart unless-stopped \
          -v /var/run/docker.sock:/var/run/docker.sock \
          registry.k8s.io/cloud-provider-kind/cloud-controller-manager:v0.6.0

        sleep 2

        if docker ps --format '{{.Names}}' | grep -q "^{{.CPK_CONTAINER}}$"; then
          echo "  [cloud-provider-kind] Running"
        else
          echo "  [cloud-provider-kind] Failed to start"
          docker logs {{.CPK_CONTAINER}} 2>&1 | tail -10
          exit 1
        fi

  _ensure-dnsmasq:
    internal: true
    cmds:
      - |
        # Check if already running
        if docker ps --format '{{.Names}}' | grep -q "^{{.DNSMASQ_CONTAINER}}$"; then
          echo "  [dnsmasq] Already running"
          exit 0
        fi

        # Remove any stopped container with same name
        docker rm -f {{.DNSMASQ_CONTAINER}} 2>/dev/null || true

        echo "  [dnsmasq] Starting container..."

        # Create dnsmasq config
        mkdir -p /tmp/kind-dnsmasq
        cat > /tmp/kind-dnsmasq/dnsmasq.conf << 'EOF'
        # Kind cluster DNS
        # Resolves *.k8s.local to the kind Docker network
        no-resolv
        no-hosts
        # Forward other queries to Google DNS
        server=8.8.8.8
        server=8.8.4.4
        # Wildcard for k8s.local - updated dynamically
        address=/k8s.local/127.0.0.1
        EOF

        docker run -d \
          --name {{.DNSMASQ_CONTAINER}} \
          --network kind \
          --restart unless-stopped \
          --cap-add NET_ADMIN \
          -p 127.0.0.1:5353:53/udp \
          -v /tmp/kind-dnsmasq:/etc/dnsmasq.d:ro \
          andyshinn/dnsmasq:latest \
          --conf-dir=/etc/dnsmasq.d,*.conf --no-daemon --log-facility=-

        sleep 2

        if docker ps --format '{{.Names}}' | grep -q "^{{.DNSMASQ_CONTAINER}}$"; then
          echo "  [dnsmasq] Running on 127.0.0.1:5353"
          echo "  [dnsmasq] Test with: dig @127.0.0.1 -p 5353 test.{{.DNSMASQ_DOMAIN}}"
        else
          echo "  [dnsmasq] Failed to start"
          docker logs {{.DNSMASQ_CONTAINER}} 2>&1 | tail -10
          exit 1
        fi

  _update-dns:
    internal: true
    cmds:
      - |
        # Skip if dnsmasq container not running
        if ! docker ps --format '{{.Names}}' | grep -q "^{{.DNSMASQ_CONTAINER}}$"; then
          exit 0
        fi

        echo "  [dnsmasq] Updating DNS entries..."

        # Rebuild config with current LoadBalancer IPs
        mkdir -p /tmp/kind-dnsmasq
        cat > /tmp/kind-dnsmasq/dnsmasq.conf << 'EOF'
        no-resolv
        no-hosts
        server=8.8.8.8
        server=8.8.4.4
        EOF

        # Add entries for all LoadBalancer services
        for cluster in $(kind get clusters 2>/dev/null); do
          kubectl --context "kind-${cluster}" get svc -A -o json 2>/dev/null | \
            jq -r '.items[] | select(.spec.type=="LoadBalancer") | select(.status.loadBalancer.ingress != null) | "address=/\(.metadata.name).\(.metadata.namespace).{{.DNSMASQ_DOMAIN}}/\(.status.loadBalancer.ingress[0].ip)"' \
            >> /tmp/kind-dnsmasq/dnsmasq.conf
        done

        # Restart dnsmasq to pick up changes
        docker restart {{.DNSMASQ_CONTAINER}} > /dev/null
        echo "  [dnsmasq] Updated"

  _stop-infrastructure:
    internal: true
    cmds:
      - |
        echo "Stopping local infrastructure containers..."
        docker rm -f {{.CPK_CONTAINER}} 2>/dev/null && echo "  Stopped {{.CPK_CONTAINER}}" || true
        docker rm -f {{.DNSMASQ_CONTAINER}} 2>/dev/null && echo "  Stopped {{.DNSMASQ_CONTAINER}}" || true
        rm -rf /tmp/kind-dnsmasq 2>/dev/null || true

  # =============================================================================
  # Orchestrator Setup
  # =============================================================================
  init:
    desc: Initialize the orchestrator cluster (ArgoCD, Argo Workflows, Crossplane)
    cmds:
      - |
        # Clean up any non-orchestrator clusters
        for cluster in $(kind get clusters 2>/dev/null); do
          if [ "$cluster" != "{{.ORCHESTRATOR_CLUSTER}}" ]; then
            echo "Removing stale cluster: $cluster"
            kind delete cluster --name "$cluster"
          fi
        done

        # Create or reuse orchestrator
        if kind get clusters 2>/dev/null | grep -q "^{{.ORCHESTRATOR_CLUSTER}}$"; then
          echo "Orchestrator cluster already exists"
        else
          echo "Creating orchestrator cluster..."
          kind create cluster --name {{.ORCHESTRATOR_CLUSTER}} --wait 60s
        fi
      - task: _ensure-dnsmasq
      - task: _ensure-cloud-provider-kind
      - kubectl config use-context kind-{{.ORCHESTRATOR_CLUSTER}}
      - helm repo add argo https://argoproj.github.io/argo-helm 2>/dev/null || true
      - helm repo update argo
      - |
        if helm status argocd -n {{.ARGOCD_NAMESPACE}} >/dev/null 2>&1; then
          echo "ArgoCD already installed"
        else
          echo "Installing ArgoCD..."
          helm install argocd argo/argo-cd \
            --namespace {{.ARGOCD_NAMESPACE}} \
            --create-namespace \
            --values {{.ARGOCD_VALUES}} \
            --wait
        fi
      - echo ""
      - echo "Deploying core infrastructure..."
      - kubectl apply -f experiments/components/core-app-of-apps.yaml
      - task: password

  reset:
    desc: Delete all clusters and reinitialize
    cmds:
      - task: _stop-infrastructure
      - |
        echo "Deleting all clusters..."
        for cluster in $(kind get clusters 2>/dev/null); do
          echo "  Deleting: $cluster"
          kind delete cluster --name "$cluster"
        done
      - task: init

  status:
    desc: Show all clusters, ArgoCD applications, and LoadBalancer services
    cmds:
      - |
        echo "=== Kind Clusters ==="
        kind get clusters 2>/dev/null || echo "No clusters"
        echo ""
        echo "=== Infrastructure Containers ==="
        echo -n "cloud-provider-kind: "
        docker ps --format '{{.Status}}' --filter name={{.CPK_CONTAINER}} 2>/dev/null | head -1 || echo "Not running"
        echo -n "dnsmasq: "
        docker ps --format '{{.Status}}' --filter name={{.DNSMASQ_CONTAINER}} 2>/dev/null | head -1 || echo "Not running"
        echo ""
        echo "=== ArgoCD Applications (orchestrator) ==="
        kubectl --context kind-{{.ORCHESTRATOR_CLUSTER}} get applications -n {{.ARGOCD_NAMESPACE}} 2>/dev/null || echo "Orchestrator not running"
        echo ""
        echo "=== LoadBalancer Services ==="
        for cluster in $(kind get clusters 2>/dev/null); do
          echo "[$cluster]"
          kubectl --context "kind-${cluster}" get svc -A 2>/dev/null | grep -E "LoadBalancer|EXTERNAL-IP" || echo "  (none)"
        done

  # =============================================================================
  # ArgoCD Helpers
  # =============================================================================
  password:
    desc: Display ArgoCD admin password
    cmds:
      - |
        echo "ArgoCD Credentials:"
        echo "  Username: admin"
        echo "  Password: $(kubectl --context kind-{{.ORCHESTRATOR_CLUSTER}} -n {{.ARGOCD_NAMESPACE}} get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d)"

  ui:
    desc: Port-forward ArgoCD UI to localhost:8080
    cmds:
      - echo "ArgoCD UI available at https://localhost:8080"
      - kubectl --context kind-{{.ORCHESTRATOR_CLUSTER}} port-forward svc/argocd-server -n {{.ARGOCD_NAMESPACE}} 8080:443

  # =============================================================================
  # Deployment (for tinkering)
  # =============================================================================
  deploy:
    desc: "Deploy ArgoCD apps to orchestrator: task local:deploy -- <paths...>"
    cmds:
      - |
        if [ -z "{{.CLI_ARGS}}" ]; then
          echo "Usage: task local:deploy -- <path> [path...]"
          echo ""
          echo "Examples:"
          echo "  task local:deploy -- experiments/components/core-app-of-apps.yaml"
          echo "  task local:deploy -- experiments/components/stacks/loki.yaml"
          exit 1
        fi

        for path in {{.CLI_ARGS}}; do
          if [ ! -f "$path" ]; then
            echo "ERROR: File not found: $path"
            exit 1
          fi
          echo "=== Deploying: $path ==="
          kubectl --context kind-{{.ORCHESTRATOR_CLUSTER}} apply -f "$path"
        done

        echo ""
        echo "Waiting for ArgoCD to sync..."
        sleep 5
        kubectl --context kind-{{.ORCHESTRATOR_CLUSTER}} get applications -n argocd
