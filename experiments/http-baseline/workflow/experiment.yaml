# HTTP Baseline Experiment Workflow
# Full lifecycle: wait for sync, run load test, cleanup resources
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: http-baseline-
  namespace: argo-workflows
  labels:
    experiment: http-baseline
spec:
  serviceAccountName: argo-workflow
  entrypoint: run-experiment
  onExit: cleanup
  arguments:
    parameters:
      - name: experiment-name
        value: "http-baseline"
      - name: users
        value: "10"
      - name: duration
        value: "60s"
      - name: target-url
        value: "http://localhost:30080"

  templates:
    - name: run-experiment
      steps:
        - - name: wait-for-sync
            template: wait-argocd-healthy

        - - name: run-load-test
            template: k6-test
            arguments:
              parameters:
                - name: users
                  value: "{{workflow.parameters.users}}"
                - name: duration
                  value: "{{workflow.parameters.duration}}"
                - name: target-url
                  value: "{{workflow.parameters.target-url}}"

        - - name: report-results
            template: complete

    # Wait for ArgoCD application to be synced and healthy
    - name: wait-argocd-healthy
      container:
        image: bitnami/kubectl:latest
        command: [sh, -c]
        args:
          - |
            echo "Waiting for ArgoCD app 'http-baseline-target' to be healthy..."
            for i in $(seq 1 36); do
              HEALTH=$(kubectl get application http-baseline-target -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
              SYNC=$(kubectl get application http-baseline-target -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
              echo "  Attempt $i: Health=$HEALTH, Sync=$SYNC"
              if [ "$HEALTH" = "Healthy" ] && [ "$SYNC" = "Synced" ]; then
                echo "ArgoCD app is healthy and synced!"
                exit 0
              fi
              sleep 5
            done
            echo "ERROR: Timeout waiting for ArgoCD app"
            exit 1

    # Run k6 load test
    - name: k6-test
      inputs:
        parameters:
          - name: users
          - name: duration
          - name: target-url
      container:
        image: grafana/k6:latest
        command: [k6, run]
        args:
          - -e
          - USERS={{inputs.parameters.users}}
          - -e
          - DURATION={{inputs.parameters.duration}}
          - -e
          - TARGET_URL={{inputs.parameters.target-url}}
          - /scripts/baseline.js
        volumeMounts:
          - name: k6-scripts
            mountPath: /scripts
      volumes:
        - name: k6-scripts
          configMap:
            name: k6-scripts

    # Report results
    - name: complete
      container:
        image: busybox
        command: [sh, -c]
        args:
          - |
            echo "========================================"
            echo "  EXPERIMENT COMPLETE"
            echo "  Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
            echo "  Status: {{workflow.status}}"
            echo "========================================"

    # Cleanup - runs on exit (success or failure)
    - name: cleanup
      container:
        image: bitnami/kubectl:latest
        command: [sh, -c]
        args:
          - |
            EXP="{{workflow.parameters.experiment-name}}"
            echo "========================================"
            echo "  CLEANUP: $EXP"
            echo "========================================"

            echo "Deleting ArgoCD Applications..."
            kubectl delete application ${EXP}-target -n argocd --ignore-not-found=true
            kubectl delete application ${EXP}-loadgen -n argocd --ignore-not-found=true

            echo "Deleting k6 ConfigMap..."
            kubectl delete configmap k6-scripts -n argo-workflows --ignore-not-found=true

            echo "Deleting cluster secret..."
            kubectl delete secret cluster-target -n argocd --ignore-not-found=true

            echo "Cleanup complete."
