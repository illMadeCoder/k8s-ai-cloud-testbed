---
interface Props {
  pageTopic: string;
  openingMessage: string;
  pageContext?: string;
  placeholder?: string;
}

const { pageTopic, openingMessage, pageContext, placeholder = 'Ask about the testbed…' } = Astro.props;
const capabilities = 'I can also browse the project source code on GitHub if you want to know how something is implemented.';
const fullOpeningMessage = openingMessage + ' ' + capabilities;
const workerUrl = 'https://voice-proxy.illmadecoder.workers.dev';
---

<div class="conv-panel" id="conv-panel" data-worker-url={workerUrl} data-page-topic={pageTopic} data-page-context={pageContext ?? ''} data-placeholder={placeholder}>
  <div class="conv-drag" id="conv-drag"><div class="conv-drag-bar"></div></div>
  <div class="conv-body" id="conv-body">
    <div class="conv-messages" id="conv-messages">
      <div class="conv-msg conv-msg-ai">
        <div class="conv-msg-role">AI</div>
        <div class="conv-msg-text">{fullOpeningMessage}</div>
      </div>
    </div>
  </div>
  <div class="conv-input-area">
    <input type="text" id="conv-input" placeholder="Ask about the testbed…" autocomplete="off" />
    <select id="conv-voice-select" class="conv-voice-select" title="AI voice" hidden>
      <option value="verse">verse</option>
      <option value="alloy">alloy</option>
      <option value="ash">ash</option>
      <option value="ballad">ballad</option>
      <option value="coral">coral</option>
      <option value="echo">echo</option>
      <option value="sage">sage</option>
      <option value="shimmer">shimmer</option>
    </select>
    <button id="conv-send-btn" class="conv-action-btn" title="Send">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" width="18" height="18">
        <line x1="22" y1="2" x2="11" y2="13"/>
        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
      </svg>
    </button>
    <button id="conv-voice-btn" class="conv-action-btn" title="Voice mode">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" width="18" height="18">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
        <line x1="12" y1="19" x2="12" y2="23"/>
        <line x1="8" y1="23" x2="16" y2="23"/>
      </svg>
    </button>
    <div class="conv-mini-viz" id="conv-mini-viz">
      <div class="conv-mini-dot"></div>
      <div class="conv-mini-dot"></div>
      <div class="conv-mini-dot"></div>
    </div>
    <button class="conv-minimize conv-action-btn" id="conv-minimize" title="Minimize">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
        <polyline points="6 9 12 15 18 9"/>
      </svg>
    </button>
  </div>
</div>

<audio id="voice-audio" autoplay></audio>

<script is:inline>
(function() {
  var panel = document.getElementById('conv-panel');
  var messages = document.getElementById('conv-messages');
  var input = document.getElementById('conv-input');
  var sendBtn = document.getElementById('conv-send-btn');
  var voiceBtn = document.getElementById('conv-voice-btn');
  var voiceSelect = document.getElementById('conv-voice-select');
  var minimizeBtn = document.getElementById('conv-minimize');
  var audioEl = document.getElementById('voice-audio');
  var miniViz = document.getElementById('conv-mini-viz');

  if (!panel) return;

  var workerUrl = panel.getAttribute('data-worker-url');
  var pageTopic = panel.getAttribute('data-page-topic') || '';
  var pageContext = panel.getAttribute('data-page-context') || '';
  var mainEl = document.querySelector('main');
  var defaultPlaceholder = panel.getAttribute('data-placeholder') || 'Ask about the testbed\u2026';

  var labPreamble = 'About this site: The K8s Cloud TestBed is an automated benchmarking lab for cloud-native technologies. A custom Kubernetes operator (Kubebuilder) provisions real GKE clusters via Crossplane, deploys competing technology stacks via ArgoCD, runs standardized workloads via Argo Workflows, collects metrics, and publishes results here. Every experiment runs on freshly provisioned infrastructure for clean baselines.\n\nThe hub cluster runs on Talos Linux and hosts the operator, ArgoCD, VictoriaMetrics, SeaweedFS, and supporting infrastructure. Target clusters are provisioned on-demand in GCP and torn down after each experiment. After completion, an AI analyzer generates summaries, per-metric insights, and recommendations.\n\nThe site is organized into: Series (long-term research tracks like "Cloud Database Internals" or "Ecosystem Comparisons"), Categories (observability, networking, storage, cicd), and individual experiment pages with detailed results, charts, and AI analysis.\n\nTech stack: Talos Linux, GKE, Crossplane, ArgoCD, Argo Workflows, Prometheus, VictoriaMetrics, Grafana, Loki, Tempo, Kyverno, OpenBao, SeaweedFS, Astro, Tailwind CSS.';

  var GITHUB_API = 'https://api.github.com/repos/illMadeCoder/k8s-ai-cloud-testbed/contents/';

  var repoTools = [
    {
      type: 'function',
      name: 'get_file',
      description: 'Read the contents of a file from the project GitHub repository. Returns the file text. Use this to answer questions about how the code works.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'File path relative to repo root, e.g. "operators/experiment-operator/internal/controller/experiment_controller.go"' }
        },
        required: ['path']
      }
    },
    {
      type: 'function',
      name: 'list_directory',
      description: 'List files and subdirectories in a directory of the project GitHub repository. Use this to explore the codebase structure before reading specific files.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Directory path relative to repo root. Use empty string "" for the repository root.' }
        },
        required: ['path']
      }
    }
  ];

  // Restore saved voice preference
  var savedVoice = localStorage.getItem('conv-voice');
  if (savedVoice && voiceSelect) {
    voiceSelect.value = savedVoice;
  }

  function getVoice() {
    return (voiceSelect && voiceSelect.value) || 'verse';
  }

  // --- Drag resize ---
  var dragHandle = document.getElementById('conv-drag');
  var panelHeight = 30; // vh
  var dragging = false;
  var dragMoved = false;

  function startDrag(e) {
    if (panelState === 'minimized') return;
    dragging = true;
    dragMoved = false;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  }

  function onDrag(e) {
    if (!dragging) return;
    dragMoved = true;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;
    var vh = ((window.innerHeight - clientY) / window.innerHeight) * 100;
    panelHeight = Math.max(10, Math.min(85, vh));
    panel.style.height = panelHeight + 'vh';
    if (mainEl) mainEl.style.paddingBottom = panelHeight + 'vh';
  }

  function endDrag() {
    if (!dragging) return;
    dragging = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    if (!dragMoved) {
      setPanelState('minimized');
    } else if (panelHeight < 20) {
      panelHeight = 50;
      setPanelState('minimized');
    }
  }

  dragHandle.addEventListener('mousedown', startDrag);
  dragHandle.addEventListener('touchstart', startDrag, { passive: false });
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('touchmove', onDrag, { passive: false });
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchend', endDrag);

  // State
  var panelState = 'open'; // open | minimized
  var connState = 'disconnected'; // disconnected | connecting | text | voice
  var connectingMode = null;
  var pc = null;
  var dc = null;
  var localStream = null;
  var audioCtx = null;
  var pendingText = null;
  var currentAiBubble = null;
  var currentAiText = '';

  // --- Padding ---
  function updatePadding() {
    if (!mainEl) return;
    if (panelState === 'open') mainEl.style.paddingBottom = panelHeight + 'vh';
    else mainEl.style.paddingBottom = '48px';
  }

  // --- Panel state ---
  function setPanelState(s) {
    panelState = s;
    panel.classList.toggle('minimized', s === 'minimized');
    if (s === 'open') panel.style.height = panelHeight + 'vh';
    else panel.style.height = '';
    updatePadding();
    if (s === 'open') scrollMessages();
    // Flip arrow: down when open, up when minimized
    var chevron = minimizeBtn.querySelector('polyline');
    if (chevron) chevron.setAttribute('points', s === 'minimized' ? '6 15 12 9 18 15' : '6 9 12 15 18 9');
  }

  // --- Messages ---
  function addMessage(role, text) {
    var msg = document.createElement('div');
    msg.className = 'conv-msg conv-msg-' + role;
    var roleEl = document.createElement('div');
    roleEl.className = 'conv-msg-role';
    roleEl.textContent = role === 'ai' ? 'AI' : 'You';
    var textEl = document.createElement('div');
    textEl.className = 'conv-msg-text';
    textEl.textContent = text;
    msg.appendChild(roleEl);
    msg.appendChild(textEl);
    messages.appendChild(msg);
    scrollMessages();
    return textEl;
  }

  function scrollMessages() {
    messages.scrollTop = messages.scrollHeight;
  }

  function startAiBubble() {
    currentAiText = '';
    currentAiBubble = addMessage('ai', '');
    return currentAiBubble;
  }

  function appendAiDelta(delta) {
    if (!currentAiBubble) startAiBubble();
    currentAiText += delta;
    currentAiBubble.textContent = currentAiText;
    scrollMessages();
  }

  function finalizeAiBubble() {
    currentAiBubble = null;
    currentAiText = '';
  }

  // --- Status ---
  function updateStatus() {
    voiceBtn.classList.toggle('active', connState === 'voice');
    voiceSelect.hidden = connState !== 'voice';
    if (connState === 'connecting') input.placeholder = 'Connecting\u2026';
    else if (connState === 'voice') input.placeholder = 'Listening\u2026 (type or speak)';
    else input.placeholder = defaultPlaceholder;
  }

  // --- Connection ---
  function createSilentStream() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var dest = audioCtx.createMediaStreamDestination();
    return dest.stream;
  }

  function cleanup() {
    if (dc) { try { dc.close(); } catch(e) {} dc = null; }
    if (pc) { try { pc.close(); } catch(e) {} pc = null; }
    if (localStream) {
      localStream.getTracks().forEach(function(t) { t.stop(); });
      localStream = null;
    }
    if (audioCtx) { try { audioCtx.close(); } catch(e) {} audioCtx = null; }
    if (audioEl) audioEl.srcObject = null;
    pendingText = null;
    currentAiBubble = null;
    currentAiText = '';
    connectingMode = null;
  }

  async function githubGetFile(filePath) {
    try {
      var res = await fetch(GITHUB_API + filePath);
      if (!res.ok) return 'Error: Could not fetch file (HTTP ' + res.status + ')';
      var data = await res.json();
      if (data.type !== 'file') return 'Error: Path is a directory, not a file. Use list_directory instead.';
      var content = atob(data.content.replace(/\n/g, ''));
      if (content.length > 12000) {
        content = content.substring(0, 12000) + '\n\n[Truncated — file is ' + data.size + ' bytes total]';
      }
      return content;
    } catch (e) {
      return 'Error: ' + e.message;
    }
  }

  async function githubListDir(dirPath) {
    try {
      var res = await fetch(GITHUB_API + (dirPath || ''));
      if (!res.ok) return 'Error: Could not list directory (HTTP ' + res.status + ')';
      var data = await res.json();
      if (!Array.isArray(data)) return 'Error: Path is a file, not a directory. Use get_file instead.';
      return data.map(function(item) {
        return (item.type === 'dir' ? 'dir:  ' : 'file: ') + item.name;
      }).join('\n');
    } catch (e) {
      return 'Error: ' + e.message;
    }
  }

  async function handleToolCall(name, args) {
    if (name === 'get_file') return await githubGetFile(args.path || '');
    if (name === 'list_directory') return await githubListDir(args.path || '');
    return 'Error: Unknown tool ' + name;
  }

  async function connect(mode) {
    if (connState !== 'disconnected') return;
    connState = 'connecting';
    connectingMode = mode;
    updateStatus();

    var stream;
    if (mode === 'voice') {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream = localStream;
      } catch(e) {
        addMessage('ai', 'Microphone access denied. You can still type messages.');
        connState = 'disconnected';
        connectingMode = null;
        updateStatus();
        return;
      }
    } else {
      stream = createSilentStream();
    }

    try {
      var tokenRes = await fetch(workerUrl + '/session', { method: 'POST' });
      if (!tokenRes.ok) {
        var errMsg = '';
        try { errMsg = (await tokenRes.json()).error; } catch(e) {}
        cleanup();
        connState = 'disconnected';
        addMessage('ai', errMsg || 'Could not start session. Please try again.');
        updateStatus();
        return;
      }

      var session = await tokenRes.json();
      var token = session.client_secret && session.client_secret.value;
      if (!token) {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Invalid session response.');
        updateStatus();
        return;
      }

      pc = new RTCPeerConnection();

      pc.ontrack = function(event) {
        if (audioEl && event.streams[0]) {
          audioEl.srcObject = event.streams[0];
          audioEl.play().catch(function() {});
        }
      };

      dc = pc.createDataChannel('oai-events');

      dc.onopen = function() {
        var mdEl = document.getElementById('page-markdown');
        var context = labPreamble;
        if (mdEl && mdEl.textContent) {
          context += '\n\nPage content:\n\n' + mdEl.textContent;
        } else if (pageContext) {
          context += '\n\nPage content:\n\n' + pageContext;
        }
        var modalities = mode === 'voice' ? ['audio', 'text'] : ['text'];
        var turnDetection = mode === 'voice' ? { type: 'server_vad' } : null;

        var brevity = ' Keep answers brief — a few sentences is ideal. Only go deeper if the user asks for detail or the question genuinely requires it.';
        var instructions = 'You are an AI assistant on the K8s Cloud TestBed, a Kubernetes benchmarking portfolio site. Always respond in English. The visitor is viewing "' + pageTopic + '". Be conversational, technically accurate, and enthusiastic. Help them understand the content on this page — results, methodology, and implications. Only reference experiments and data mentioned in the provided context — never invent experiments. You have access to tools that can browse the project GitHub repository — use them to look up code, configs, or directory structure when the user asks about implementation details.' + brevity + (mode === 'voice' ? ' Keep responses extra concise for voice.' : '') + '\n\nContext:\n\n' + context;

        dc.send(JSON.stringify({
          type: 'session.update',
          session: {
            modalities: modalities,
            voice: getVoice(),
            instructions: instructions,
            tools: repoTools,
            input_audio_transcription: { model: 'whisper-1' },
            turn_detection: turnDetection
          }
        }));
      };

      dc.onmessage = handleDcMessage;

      dc.onerror = function() {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Connection lost. Send another message to reconnect.');
        updateStatus();
      };

      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });

      var offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      var sdpRes = await fetch('https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + token,
          'Content-Type': 'application/sdp',
        },
        body: offer.sdp,
      });

      if (!sdpRes.ok) {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Could not connect to AI service.');
        updateStatus();
        return;
      }

      var answerSdp = await sdpRes.text();
      await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

      pc.onconnectionstatechange = function() {
        if (pc && (pc.connectionState === 'disconnected' || pc.connectionState === 'failed')) {
          var prevMode = connState;
          cleanup();
          connState = 'disconnected';
          finalizeAiBubble();
          updateStatus();
          if (prevMode === 'voice' || prevMode === 'text') {
            connect(prevMode);
          }
        }
      };

      dc.onclose = function() {
        if (connState === 'disconnected') return;
        var prevMode = connState;
        cleanup();
        connState = 'disconnected';
        finalizeAiBubble();
        updateStatus();
        if (prevMode === 'voice' || prevMode === 'text') {
          connect(prevMode);
        }
      };

    } catch(e) {
      console.error('[Conv] Connection error:', e);
      cleanup();
      connState = 'disconnected';
      addMessage('ai', 'Connection failed. Please try again.');
      updateStatus();
    }
  }

  function handleDcMessage(event) {
    try {
      var msg = JSON.parse(event.data);

      switch (msg.type) {
        case 'session.updated':
          if (connectingMode) {
            connState = connectingMode;
            connectingMode = null;
            updateStatus();
            if (pendingText) {
              doSendText(pendingText);
              pendingText = null;
            }
          }
          break;

        case 'response.text.delta':
          if (msg.delta) appendAiDelta(msg.delta);
          miniViz.classList.add('speaking');
          miniViz.classList.remove('listening');
          panel.classList.add('ai-responding');
          break;

        case 'response.audio_transcript.delta':
          if (msg.delta) appendAiDelta(msg.delta);
          miniViz.classList.add('speaking');
          miniViz.classList.remove('listening');
          panel.classList.add('ai-responding');
          break;

        case 'response.text.done':
        case 'response.audio_transcript.done':
          finalizeAiBubble();
          break;

        case 'response.done':
          finalizeAiBubble();
          miniViz.classList.remove('speaking');
          panel.classList.remove('ai-responding');
          if (connState === 'voice') miniViz.classList.add('listening');
          else miniViz.classList.remove('listening');
          break;

        case 'input_audio_buffer.speech_started':
          miniViz.classList.add('listening');
          miniViz.classList.remove('speaking');
          break;

        case 'conversation.item.input_audio_transcription.completed':
          if (msg.transcript) addMessage('user', msg.transcript);
          break;

        case 'response.function_call_arguments.done':
          var callId = msg.call_id;
          var fnName = msg.name;
          var fnArgs;
          try { fnArgs = JSON.parse(msg.arguments); } catch(e) { fnArgs = {}; }
          appendAiDelta('[Looking up ' + fnName.replace('_', ' ') + ': ' + (fnArgs.path || '/') + '...]');
          handleToolCall(fnName, fnArgs).then(function(result) {
            finalizeAiBubble();
            dc.send(JSON.stringify({
              type: 'conversation.item.create',
              item: {
                type: 'function_call_output',
                call_id: callId,
                output: result
              }
            }));
            dc.send(JSON.stringify({ type: 'response.create' }));
          });
          break;

        case 'error':
          console.error('[Conv] API error:', msg.error);
          if (msg.error && msg.error.message) {
            addMessage('ai', 'Error: ' + msg.error.message);
          }
          break;
      }
    } catch(e) {}
  }

  function doSendText(text) {
    if (!dc || dc.readyState !== 'open') return;
    dc.send(JSON.stringify({
      type: 'conversation.item.create',
      item: {
        type: 'message',
        role: 'user',
        content: [{ type: 'input_text', text: text }]
      }
    }));
    dc.send(JSON.stringify({ type: 'response.create' }));
  }

  // --- Send text ---
  async function sendText() {
    var text = input.value.trim();
    if (!text) return;
    input.value = '';
    addMessage('user', text);

    if (connState === 'disconnected') {
      pendingText = text;
      await connect('text');
    } else if (connState === 'connecting') {
      pendingText = text;
    } else {
      doSendText(text);
    }
  }

  // --- Voice toggle ---
  async function toggleVoice() {
    if (connState === 'voice') {
      // Switch back to text
      if (localStream) {
        localStream.getTracks().forEach(function(t) { t.enabled = false; });
      }
      connState = 'text';
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify({
          type: 'session.update',
          session: { modalities: ['text'], turn_detection: null }
        }));
      }
      miniViz.classList.remove('listening', 'speaking');
      updateStatus();
      return;
    }

    if (connState === 'connecting') return;

    if (connState === 'disconnected') {
      await connect('voice');
      return;
    }

    // Text mode → voice mode
    try {
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        if (pc) {
          var senders = pc.getSenders();
          var audioSender = senders.find(function(s) {
            return s.track && s.track.kind === 'audio';
          });
          if (audioSender) {
            await audioSender.replaceTrack(localStream.getAudioTracks()[0]);
          }
        }
      } else {
        localStream.getTracks().forEach(function(t) { t.enabled = true; });
      }

      connState = 'voice';
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify({
          type: 'session.update',
          session: { modalities: ['audio', 'text'], turn_detection: { type: 'server_vad' } }
        }));
      }
      miniViz.classList.add('listening');
      updateStatus();
    } catch(e) {
      addMessage('ai', 'Microphone access denied. You can still type messages.');
    }
  }

  // --- Event listeners ---
  sendBtn.addEventListener('click', sendText);
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendText();
    }
  });
  voiceBtn.addEventListener('click', toggleVoice);
  minimizeBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    var next = panelState === 'minimized' ? 'open' : 'minimized';
    if (next === 'minimized') input.blur();
    setPanelState(next);
  });
  input.addEventListener('focus', function() {
    if (panelState === 'minimized') setPanelState('open');
  });
  voiceSelect.addEventListener('change', function() {
    localStorage.setItem('conv-voice', voiceSelect.value);
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({
        type: 'session.update',
        session: { voice: voiceSelect.value }
      }));
    }
  });
  voiceSelect.addEventListener('click', function(e) { e.stopPropagation(); });

  // Init
  setPanelState('minimized');
  updateStatus();
})();
</script>

<style>
  .conv-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30vh;
    display: flex;
    flex-direction: column;
    background: rgba(15, 23, 42, 0.82);
    backdrop-filter: blur(16px) saturate(1.2);
    -webkit-backdrop-filter: blur(16px) saturate(1.2);
    border-top: 1px solid rgba(255, 255, 255, 0.08);
    box-shadow:
      0 -4px 30px rgba(0, 0, 0, 0.5),
      inset 0 1px 0 rgba(255, 255, 255, 0.05);
    z-index: 100;
    transition: height 0.3s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.2s ease;
  }

  .conv-drag {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 12px;
    cursor: ns-resize;
  }
  .conv-drag-bar {
    width: 40px;
    height: 4px;
    border-radius: 2px;
    background: var(--border);
    transition: background 0.15s, width 0.2s;
  }
  .conv-drag:hover .conv-drag-bar {
    background: color-mix(in srgb, var(--accent) 50%, transparent);
    width: 50px;
  }
  .conv-panel.minimized .conv-drag {
    display: none;
  }

  /* Mini viz dots */
  .conv-mini-viz {
    display: none;
    align-items: center;
    gap: 3px;
  }
  .conv-mini-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-muted);
  }

  /* Body */
  .conv-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  /* Messages */
  .conv-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    min-height: 0;
  }

  /* Message bubbles */
  .conv-msg {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
    max-width: 85%;
    animation: msgIn 0.25s ease-out both;
  }
  .conv-msg-ai {
    align-self: flex-start;
  }
  .conv-msg-user {
    align-self: flex-end;
  }
  .conv-msg-role {
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-muted);
  }
  .conv-msg-user .conv-msg-role {
    text-align: right;
  }
  .conv-msg-text {
    font-family: var(--font-mono);
    font-size: 0.85rem;
    line-height: 1.6;
    padding: 0.6rem 0.85rem;
    border-radius: var(--radius);
    word-break: break-word;
  }
  .conv-msg-ai .conv-msg-text {
    background: rgba(255, 255, 255, 0.03);
    border: none;
    border-left: 2px solid var(--accent);
    border-radius: 0 var(--radius) var(--radius) 0;
    color: var(--text);
    text-shadow: 0 0 3px color-mix(in srgb, var(--accent) 10%, transparent);
  }
  .conv-msg-user .conv-msg-text {
    background: color-mix(in srgb, var(--accent) 15%, var(--bg-surface));
    border: 1px solid color-mix(in srgb, var(--accent) 20%, transparent);
    color: var(--text);
  }

  /* Input area */
  .conv-input-area {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-top: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(0, 0, 0, 0.2);
  }
  #conv-input {
    flex: 1;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.5rem 0.75rem;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    color: var(--text);
    outline: none;
  }
  #conv-input:focus {
    border-color: color-mix(in srgb, var(--accent) 50%, transparent);
    box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent) 12%, transparent);
  }
  #conv-input::placeholder {
    color: var(--text-muted);
  }
  .conv-voice-select {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.3rem 0.4rem;
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--text-muted);
    cursor: pointer;
    outline: none;
  }
  .conv-voice-select:focus {
    border-color: var(--accent);
  }
  .conv-action-btn {
    background: none;
    border: 1px solid transparent;
    border-radius: var(--radius);
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.4rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.15s, color 0.15s, background 0.15s, box-shadow 0.15s;
  }
  .conv-action-btn:hover {
    background: color-mix(in srgb, var(--accent) 10%, transparent);
    border-color: color-mix(in srgb, var(--accent) 25%, transparent);
    color: var(--accent);
    box-shadow: 0 0 8px color-mix(in srgb, var(--accent) 12%, transparent);
  }
  .conv-action-btn.active {
    background: color-mix(in srgb, var(--accent) 15%, var(--bg-surface));
    border-color: var(--accent);
    color: var(--accent);
  }

  /* Minimized state */
  .conv-panel.minimized .conv-drag {
    display: none;
  }
  .conv-panel.minimized .conv-body {
    display: none;
  }
  .conv-panel.minimized {
    height: auto;
    opacity: 0.9;
  }

  /* Mini viz animations */
  .conv-mini-viz.speaking .conv-mini-dot {
    background: var(--success, #22c55e);
    animation: conv-speak 0.6s ease-in-out infinite alternate;
    box-shadow: 0 0 6px color-mix(in srgb, var(--success) 60%, transparent);
  }
  .conv-mini-viz.speaking .conv-mini-dot:nth-child(2) { animation-delay: 0.15s; }
  .conv-mini-viz.speaking .conv-mini-dot:nth-child(3) { animation-delay: 0.3s; }
  .conv-mini-viz.listening .conv-mini-dot {
    background: var(--accent);
    animation: conv-pulse 1.4s ease-in-out infinite;
    box-shadow: 0 0 6px color-mix(in srgb, var(--accent) 60%, transparent);
  }
  .conv-mini-viz.listening .conv-mini-dot:nth-child(2) { animation-delay: 0.2s; }
  .conv-mini-viz.listening .conv-mini-dot:nth-child(3) { animation-delay: 0.4s; }

  @keyframes conv-pulse {
    0%, 100% { transform: scale(1); opacity: 0.5; }
    50% { transform: scale(1.5); opacity: 1; }
  }
  @keyframes conv-speak {
    0% { transform: scaleY(1); }
    100% { transform: scaleY(2.5); }
  }

  /* Message entrance animation */
  @keyframes msgIn {
    from { opacity: 0; transform: translateY(6px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  /* Animated gradient top-border (AI responding) */
  @property --border-angle {
    inherits: false;
    initial-value: 0deg;
    syntax: "<angle>";
  }
  .conv-panel.ai-responding {
    border-image: conic-gradient(
      from var(--border-angle),
      var(--accent), #a855f7, var(--accent)
    ) 1;
    animation: borderSpin 3s linear infinite;
  }
  @keyframes borderSpin {
    to { --border-angle: 360deg; }
  }

  /* Scanline texture overlay */
  .conv-panel::after {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(255, 255, 255, 0.02) 0px,
      rgba(255, 255, 255, 0.02) 1px,
      transparent 1px,
      transparent 3px
    );
    pointer-events: none;
    border-radius: inherit;
    z-index: 1;
  }

  /* Responsive */
  @media (max-width: 640px) {
    .conv-panel {
      height: 30vh;
    }
    .conv-msg {
      max-width: 92%;
    }
  }

</style>
