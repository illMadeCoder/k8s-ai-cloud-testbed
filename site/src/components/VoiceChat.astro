---
interface Props {
  pageTopic: string;
  openingMessage: string;
  pageContext?: string;
}

const { pageTopic, openingMessage, pageContext } = Astro.props;
const workerUrl = 'https://voice-proxy.illmadecoder.workers.dev';
---

<div class="conv-panel" id="conv-panel" data-worker-url={workerUrl} data-page-topic={pageTopic} data-page-context={pageContext ?? ''}>
  <div class="conv-drag" id="conv-drag"><div class="conv-drag-bar"></div></div>
  <div class="conv-body" id="conv-body">
    <div class="conv-messages" id="conv-messages">
      <div class="conv-msg conv-msg-ai">
        <div class="conv-msg-role">AI</div>
        <div class="conv-msg-text">{openingMessage}</div>
      </div>
    </div>
  </div>
  <div class="conv-input-area">
    <input type="text" id="conv-input" placeholder="Ask about experiments..." autocomplete="off" />
    <select id="conv-voice-select" class="conv-voice-select" title="AI voice" hidden>
      <option value="verse">verse</option>
      <option value="alloy">alloy</option>
      <option value="ash">ash</option>
      <option value="ballad">ballad</option>
      <option value="coral">coral</option>
      <option value="echo">echo</option>
      <option value="sage">sage</option>
      <option value="shimmer">shimmer</option>
    </select>
    <button id="conv-send-btn" class="conv-action-btn" title="Send">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" width="18" height="18">
        <line x1="22" y1="2" x2="11" y2="13"/>
        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
      </svg>
    </button>
    <button id="conv-voice-btn" class="conv-action-btn" title="Voice mode">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
           stroke-linecap="round" stroke-linejoin="round" width="18" height="18">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
        <line x1="12" y1="19" x2="12" y2="23"/>
        <line x1="8" y1="23" x2="16" y2="23"/>
      </svg>
    </button>
    <div class="conv-mini-viz" id="conv-mini-viz">
      <div class="conv-mini-dot"></div>
      <div class="conv-mini-dot"></div>
      <div class="conv-mini-dot"></div>
    </div>
    <button class="conv-minimize conv-action-btn" id="conv-minimize" title="Minimize">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
        <polyline points="6 9 12 15 18 9"/>
      </svg>
    </button>
  </div>
</div>

<audio id="voice-audio" autoplay></audio>

<script is:inline>
(function() {
  var panel = document.getElementById('conv-panel');
  var messages = document.getElementById('conv-messages');
  var input = document.getElementById('conv-input');
  var sendBtn = document.getElementById('conv-send-btn');
  var voiceBtn = document.getElementById('conv-voice-btn');
  var voiceSelect = document.getElementById('conv-voice-select');
  var minimizeBtn = document.getElementById('conv-minimize');
  var audioEl = document.getElementById('voice-audio');
  var miniViz = document.getElementById('conv-mini-viz');

  if (!panel) return;

  var workerUrl = panel.getAttribute('data-worker-url');
  var pageTopic = panel.getAttribute('data-page-topic') || '';
  var pageContext = panel.getAttribute('data-page-context') || '';
  var mainEl = document.querySelector('main');
  var hasContext = !!document.getElementById('page-markdown') || !!pageContext;

  // Restore saved voice preference
  var savedVoice = localStorage.getItem('conv-voice');
  if (savedVoice && voiceSelect) {
    voiceSelect.value = savedVoice;
  }

  function getVoice() {
    return (voiceSelect && voiceSelect.value) || 'verse';
  }

  // --- Drag resize ---
  var dragHandle = document.getElementById('conv-drag');
  var panelHeight = 30; // vh
  var dragging = false;
  var dragMoved = false;

  function startDrag(e) {
    if (panelState === 'minimized') return;
    dragging = true;
    dragMoved = false;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  }

  function onDrag(e) {
    if (!dragging) return;
    dragMoved = true;
    var clientY = e.touches ? e.touches[0].clientY : e.clientY;
    var vh = ((window.innerHeight - clientY) / window.innerHeight) * 100;
    panelHeight = Math.max(10, Math.min(85, vh));
    panel.style.height = panelHeight + 'vh';
    if (mainEl) mainEl.style.paddingBottom = panelHeight + 'vh';
  }

  function endDrag() {
    if (!dragging) return;
    dragging = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    if (!dragMoved) {
      setPanelState('minimized');
    } else if (panelHeight < 20) {
      panelHeight = 50;
      setPanelState('minimized');
    }
  }

  dragHandle.addEventListener('mousedown', startDrag);
  dragHandle.addEventListener('touchstart', startDrag, { passive: false });
  document.addEventListener('mousemove', onDrag);
  document.addEventListener('touchmove', onDrag, { passive: false });
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchend', endDrag);

  // State
  var panelState = 'open'; // open | minimized
  var connState = 'disconnected'; // disconnected | connecting | text | voice
  var connectingMode = null;
  var pc = null;
  var dc = null;
  var localStream = null;
  var audioCtx = null;
  var pendingText = null;
  var currentAiBubble = null;
  var currentAiText = '';

  // --- Padding ---
  function updatePadding() {
    if (!mainEl) return;
    if (panelState === 'open') mainEl.style.paddingBottom = panelHeight + 'vh';
    else mainEl.style.paddingBottom = '48px';
  }

  // --- Panel state ---
  function setPanelState(s) {
    panelState = s;
    panel.classList.toggle('minimized', s === 'minimized');
    if (s === 'open') panel.style.height = panelHeight + 'vh';
    else panel.style.height = '';
    updatePadding();
    if (s === 'open') scrollMessages();
    // Flip arrow: down when open, up when minimized
    var chevron = minimizeBtn.querySelector('polyline');
    if (chevron) chevron.setAttribute('points', s === 'minimized' ? '6 15 12 9 18 15' : '6 9 12 15 18 9');
  }

  // --- Messages ---
  function addMessage(role, text) {
    var msg = document.createElement('div');
    msg.className = 'conv-msg conv-msg-' + role;
    var roleEl = document.createElement('div');
    roleEl.className = 'conv-msg-role';
    roleEl.textContent = role === 'ai' ? 'AI' : 'You';
    var textEl = document.createElement('div');
    textEl.className = 'conv-msg-text';
    textEl.textContent = text;
    msg.appendChild(roleEl);
    msg.appendChild(textEl);
    messages.appendChild(msg);
    scrollMessages();
    return textEl;
  }

  function scrollMessages() {
    messages.scrollTop = messages.scrollHeight;
  }

  function startAiBubble() {
    currentAiText = '';
    currentAiBubble = addMessage('ai', '');
    return currentAiBubble;
  }

  function appendAiDelta(delta) {
    if (!currentAiBubble) startAiBubble();
    currentAiText += delta;
    currentAiBubble.textContent = currentAiText;
    scrollMessages();
  }

  function finalizeAiBubble() {
    currentAiBubble = null;
    currentAiText = '';
  }

  // --- Status ---
  function updateStatus() {
    voiceBtn.classList.toggle('active', connState === 'voice');
    voiceSelect.hidden = connState !== 'voice';
    if (connState === 'connecting') input.placeholder = 'Connecting\u2026';
    else if (connState === 'voice') input.placeholder = 'Listening\u2026 (type or speak)';
    else input.placeholder = hasContext ? 'Ask about this page\u2026' : 'Ask about experiments\u2026';
  }

  // --- Connection ---
  function createSilentStream() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var dest = audioCtx.createMediaStreamDestination();
    return dest.stream;
  }

  function cleanup() {
    if (dc) { try { dc.close(); } catch(e) {} dc = null; }
    if (pc) { try { pc.close(); } catch(e) {} pc = null; }
    if (localStream) {
      localStream.getTracks().forEach(function(t) { t.stop(); });
      localStream = null;
    }
    if (audioCtx) { try { audioCtx.close(); } catch(e) {} audioCtx = null; }
    if (audioEl) audioEl.srcObject = null;
    pendingText = null;
    currentAiBubble = null;
    currentAiText = '';
    connectingMode = null;
  }

  async function connect(mode) {
    if (connState !== 'disconnected') return;
    connState = 'connecting';
    connectingMode = mode;
    updateStatus();

    var stream;
    if (mode === 'voice') {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream = localStream;
      } catch(e) {
        addMessage('ai', 'Microphone access denied. You can still type messages.');
        connState = 'disconnected';
        connectingMode = null;
        updateStatus();
        return;
      }
    } else {
      stream = createSilentStream();
    }

    try {
      var tokenRes = await fetch(workerUrl + '/session', { method: 'POST' });
      if (!tokenRes.ok) {
        var errMsg = '';
        try { errMsg = (await tokenRes.json()).error; } catch(e) {}
        cleanup();
        connState = 'disconnected';
        addMessage('ai', errMsg || 'Could not start session. Please try again.');
        updateStatus();
        return;
      }

      var session = await tokenRes.json();
      var token = session.client_secret && session.client_secret.value;
      if (!token) {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Invalid session response.');
        updateStatus();
        return;
      }

      pc = new RTCPeerConnection();

      pc.ontrack = function(event) {
        if (audioEl && event.streams[0]) {
          audioEl.srcObject = event.streams[0];
          audioEl.play().catch(function() {});
        }
      };

      dc = pc.createDataChannel('oai-events');

      dc.onopen = function() {
        var mdEl = document.getElementById('page-markdown');
        var context = mdEl ? mdEl.textContent : pageContext;
        var hasCtx = !!context;
        var modalities = mode === 'voice' ? ['audio', 'text'] : ['text'];
        var turnDetection = mode === 'voice' ? { type: 'server_vad' } : null;

        var brevity = ' Keep answers brief — a few sentences is ideal. Only go deeper if the user asks for detail or the question genuinely requires it.';
        var instructions;
        if (hasCtx) {
          instructions = 'You are an AI assistant on the K8s Cloud TestBed, a Kubernetes benchmarking portfolio site. Always respond in English. The visitor is viewing "' + pageTopic + '". Be conversational, technically accurate, and enthusiastic. Help them understand the content on this page — results, methodology, and implications.' + brevity + (mode === 'voice' ? ' Keep responses extra concise for voice.' : '') + '\n\nPage content:\n\n' + context;
        } else {
          instructions = 'You are an AI assistant on the K8s Cloud TestBed, a Kubernetes benchmarking portfolio site. Always respond in English. The current page is "' + pageTopic + '". Help visitors explore benchmark experiments, discover research series, understand the methodology, and navigate to specific results. Be conversational, technically accurate, and enthusiastic.' + brevity + (mode === 'voice' ? ' Keep responses extra concise for voice.' : '');
        }

        dc.send(JSON.stringify({
          type: 'session.update',
          session: {
            modalities: modalities,
            voice: getVoice(),
            instructions: instructions,
            input_audio_transcription: { model: 'whisper-1' },
            turn_detection: turnDetection
          }
        }));
      };

      dc.onmessage = handleDcMessage;

      dc.onerror = function() {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Connection lost. Send another message to reconnect.');
        updateStatus();
      };

      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });

      var offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      var sdpRes = await fetch('https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview', {
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + token,
          'Content-Type': 'application/sdp',
        },
        body: offer.sdp,
      });

      if (!sdpRes.ok) {
        cleanup();
        connState = 'disconnected';
        addMessage('ai', 'Could not connect to AI service.');
        updateStatus();
        return;
      }

      var answerSdp = await sdpRes.text();
      await pc.setRemoteDescription({ type: 'answer', sdp: answerSdp });

      pc.onconnectionstatechange = function() {
        if (pc && (pc.connectionState === 'disconnected' || pc.connectionState === 'failed')) {
          var prevMode = connState;
          cleanup();
          connState = 'disconnected';
          finalizeAiBubble();
          updateStatus();
          if (prevMode === 'voice' || prevMode === 'text') {
            connect(prevMode);
          }
        }
      };

      dc.onclose = function() {
        if (connState === 'disconnected') return;
        var prevMode = connState;
        cleanup();
        connState = 'disconnected';
        finalizeAiBubble();
        updateStatus();
        if (prevMode === 'voice' || prevMode === 'text') {
          connect(prevMode);
        }
      };

    } catch(e) {
      console.error('[Conv] Connection error:', e);
      cleanup();
      connState = 'disconnected';
      addMessage('ai', 'Connection failed. Please try again.');
      updateStatus();
    }
  }

  function handleDcMessage(event) {
    try {
      var msg = JSON.parse(event.data);

      switch (msg.type) {
        case 'session.updated':
          if (connectingMode) {
            connState = connectingMode;
            connectingMode = null;
            updateStatus();
            if (pendingText) {
              doSendText(pendingText);
              pendingText = null;
            }
          }
          break;

        case 'response.text.delta':
          if (msg.delta) appendAiDelta(msg.delta);
          miniViz.classList.add('speaking');
          miniViz.classList.remove('listening');
          break;

        case 'response.audio_transcript.delta':
          if (msg.delta) appendAiDelta(msg.delta);
          miniViz.classList.add('speaking');
          miniViz.classList.remove('listening');
          break;

        case 'response.text.done':
        case 'response.audio_transcript.done':
          finalizeAiBubble();
          break;

        case 'response.done':
          finalizeAiBubble();
          miniViz.classList.remove('speaking');
          if (connState === 'voice') miniViz.classList.add('listening');
          else miniViz.classList.remove('listening');
          break;

        case 'input_audio_buffer.speech_started':
          miniViz.classList.add('listening');
          miniViz.classList.remove('speaking');
          break;

        case 'conversation.item.input_audio_transcription.completed':
          if (msg.transcript) addMessage('user', msg.transcript);
          break;

        case 'error':
          console.error('[Conv] API error:', msg.error);
          if (msg.error && msg.error.message) {
            addMessage('ai', 'Error: ' + msg.error.message);
          }
          break;
      }
    } catch(e) {}
  }

  function doSendText(text) {
    if (!dc || dc.readyState !== 'open') return;
    dc.send(JSON.stringify({
      type: 'conversation.item.create',
      item: {
        type: 'message',
        role: 'user',
        content: [{ type: 'input_text', text: text }]
      }
    }));
    dc.send(JSON.stringify({ type: 'response.create' }));
  }

  // --- Send text ---
  async function sendText() {
    var text = input.value.trim();
    if (!text) return;
    input.value = '';
    addMessage('user', text);

    if (connState === 'disconnected') {
      pendingText = text;
      await connect('text');
    } else if (connState === 'connecting') {
      pendingText = text;
    } else {
      doSendText(text);
    }
  }

  // --- Voice toggle ---
  async function toggleVoice() {
    if (connState === 'voice') {
      // Switch back to text
      if (localStream) {
        localStream.getTracks().forEach(function(t) { t.enabled = false; });
      }
      connState = 'text';
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify({
          type: 'session.update',
          session: { modalities: ['text'], turn_detection: null }
        }));
      }
      miniViz.classList.remove('listening', 'speaking');
      updateStatus();
      return;
    }

    if (connState === 'connecting') return;

    if (connState === 'disconnected') {
      await connect('voice');
      return;
    }

    // Text mode → voice mode
    try {
      if (!localStream) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        if (pc) {
          var senders = pc.getSenders();
          var audioSender = senders.find(function(s) {
            return s.track && s.track.kind === 'audio';
          });
          if (audioSender) {
            await audioSender.replaceTrack(localStream.getAudioTracks()[0]);
          }
        }
      } else {
        localStream.getTracks().forEach(function(t) { t.enabled = true; });
      }

      connState = 'voice';
      if (dc && dc.readyState === 'open') {
        dc.send(JSON.stringify({
          type: 'session.update',
          session: { modalities: ['audio', 'text'], turn_detection: { type: 'server_vad' } }
        }));
      }
      miniViz.classList.add('listening');
      updateStatus();
    } catch(e) {
      addMessage('ai', 'Microphone access denied. You can still type messages.');
    }
  }

  // --- Event listeners ---
  sendBtn.addEventListener('click', sendText);
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendText();
    }
  });
  voiceBtn.addEventListener('click', toggleVoice);
  minimizeBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    setPanelState(panelState === 'minimized' ? 'open' : 'minimized');
  });
  input.addEventListener('focus', function() {
    if (panelState === 'minimized') setPanelState('open');
  });
  voiceSelect.addEventListener('change', function() {
    localStorage.setItem('conv-voice', voiceSelect.value);
    if (dc && dc.readyState === 'open') {
      dc.send(JSON.stringify({
        type: 'session.update',
        session: { voice: voiceSelect.value }
      }));
    }
  });
  voiceSelect.addEventListener('click', function(e) { e.stopPropagation(); });

  // Init
  setPanelState('minimized');
  updateStatus();
})();
</script>

<style>
  .conv-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 30vh;
    display: flex;
    flex-direction: column;
    background: var(--bg-card);
    border-top: 2px solid var(--accent);
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
    z-index: 100;
  }

  .conv-drag {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 12px;
    cursor: ns-resize;
  }
  .conv-drag-bar {
    width: 40px;
    height: 4px;
    border-radius: 2px;
    background: var(--border);
    transition: background 0.15s;
  }
  .conv-drag:hover .conv-drag-bar {
    background: var(--text-muted);
  }
  .conv-panel.minimized .conv-drag {
    display: none;
  }

  /* Mini viz dots */
  .conv-mini-viz {
    display: none;
    align-items: center;
    gap: 3px;
  }
  .conv-mini-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-muted);
  }

  /* Body */
  .conv-body {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }

  /* Messages */
  .conv-messages {
    flex: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    min-height: 0;
  }

  /* Message bubbles */
  .conv-msg {
    display: flex;
    flex-direction: column;
    gap: 0.2rem;
    max-width: 85%;
  }
  .conv-msg-ai {
    align-self: flex-start;
  }
  .conv-msg-user {
    align-self: flex-end;
  }
  .conv-msg-role {
    font-family: var(--font-mono);
    font-size: 0.65rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--text-muted);
  }
  .conv-msg-user .conv-msg-role {
    text-align: right;
  }
  .conv-msg-text {
    font-family: var(--font-mono);
    font-size: 0.85rem;
    line-height: 1.6;
    padding: 0.6rem 0.85rem;
    border-radius: var(--radius);
    word-break: break-word;
  }
  .conv-msg-ai .conv-msg-text {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    color: var(--text);
  }
  .conv-msg-user .conv-msg-text {
    background: color-mix(in srgb, var(--accent) 15%, var(--bg-surface));
    border: 1px solid color-mix(in srgb, var(--accent) 30%, transparent);
    color: var(--text);
  }

  /* Input area */
  .conv-input-area {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border-top: 1px solid var(--border);
    background: var(--bg-surface);
  }
  #conv-input {
    flex: 1;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.5rem 0.75rem;
    font-family: var(--font-mono);
    font-size: 0.85rem;
    color: var(--text);
    outline: none;
  }
  #conv-input:focus {
    border-color: var(--accent);
  }
  #conv-input::placeholder {
    color: var(--text-muted);
  }
  .conv-voice-select {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 0.3rem 0.4rem;
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--text-muted);
    cursor: pointer;
    outline: none;
  }
  .conv-voice-select:focus {
    border-color: var(--accent);
  }
  .conv-action-btn {
    background: none;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    color: var(--text-muted);
    cursor: pointer;
    padding: 0.4rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: border-color 0.15s, color 0.15s, background 0.15s;
  }
  .conv-action-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
  }
  .conv-action-btn.active {
    background: color-mix(in srgb, var(--accent) 15%, var(--bg-surface));
    border-color: var(--accent);
    color: var(--accent);
  }

  /* Minimized state */
  .conv-panel.minimized .conv-drag {
    display: none;
  }
  .conv-panel.minimized .conv-body {
    display: none;
  }
  .conv-panel.minimized {
    height: auto;
  }

  /* Mini viz animations */
  .conv-mini-viz.speaking .conv-mini-dot {
    background: var(--success, #22c55e);
    animation: conv-speak 0.6s ease-in-out infinite alternate;
  }
  .conv-mini-viz.speaking .conv-mini-dot:nth-child(2) { animation-delay: 0.15s; }
  .conv-mini-viz.speaking .conv-mini-dot:nth-child(3) { animation-delay: 0.3s; }
  .conv-mini-viz.listening .conv-mini-dot {
    background: var(--accent);
    animation: conv-pulse 1.4s ease-in-out infinite;
  }
  .conv-mini-viz.listening .conv-mini-dot:nth-child(2) { animation-delay: 0.2s; }
  .conv-mini-viz.listening .conv-mini-dot:nth-child(3) { animation-delay: 0.4s; }

  @keyframes conv-pulse {
    0%, 100% { transform: scale(1); opacity: 0.5; }
    50% { transform: scale(1.5); opacity: 1; }
  }
  @keyframes conv-speak {
    0% { transform: scaleY(1); }
    100% { transform: scaleY(2.5); }
  }

  /* Responsive */
  @media (max-width: 640px) {
    .conv-panel {
      height: 30vh;
    }
    .conv-msg {
      max-width: 92%;
    }
  }

</style>
